## 2724. Sort By

**โจทย์**: สร้างฟังก์ชัน `sortBy` ที่รับอาเรย์ `arr` และฟังก์ชัน `fn` แล้วคืนอาเรย์ใหม่ที่เรียงลำดับตามค่าที่ได้จาก `fn(item)` โดยไม่แก้ไขอาเรย์เดิม

### ลายเซ็นฟังก์ชัน

```js
var sortBy = function(arr, fn) => Array
```

### ตัวอย่าง

```js
sortBy([5, 4, 1, 2, 3], (x) => x)
// ผลลัพธ์: [1, 2, 3, 4, 5]

sortBy([{"x": 1}, {"x": 0}, {"x": -1}], (d) => d.x)
// ผลลัพธ์: [{"x": -1}, {"x": 0}, {"x": 1}]

sortBy([[3, 4], [5, 2], [10, 1]], (x) => x[1])
// ผลลัพธ์: [[10, 1], [5, 2], [3, 4]]
```

### แนวคิดวิธีแก้ (ที่ใช้ในไฟล์ `solution.js`)

- ใช้ spread operator `[...arr]` เพื่อสร้างสำเนาของอาเรย์เดิม (ไม่แก้ไขอาเรย์ต้นฉบับ)
- ใช้ `Array.prototype.sort()` พร้อมฟังก์ชันเปรียบเทียบ `(a, b) => fn(a) - fn(b)`
- ฟังก์ชันเปรียบเทียบจะเปรียบเทียบค่าที่ได้จาก `fn(a)` และ `fn(b)` แทนที่จะเปรียบเทียบ `a` และ `b` โดยตรง

### โค้ด (ดูใน `solution.js`)

```js
var sortBy = function(arr, fn) {
    return [...arr].sort((a, b) => fn(a) - fn(b));
};
```

### ความซับซ้อน

- เวลา: O(n log n) — การเรียงลำดับใช้เวลา O(n log n) ในกรณีเฉลี่ย
- หน่วยความจำ: O(n) — สร้างสำเนาของอาเรย์เดิม

### กรณีขอบ (Edge Cases)

- อาเรย์ว่าง `[]` ควรคืน `[]`
- อาเรย์ที่มีสมาชิกเดียว `[1]` ควรคืน `[1]`
- หาก `fn` คืนค่า `NaN` หรือ `undefined` อาจทำให้การเรียงลำดับไม่ถูกต้อง
- หาก `fn` คืนค่าที่ไม่ใช่ตัวเลข การลบ `fn(a) - fn(b)` อาจให้ผลลัพธ์ที่ไม่คาดคิด

### วิธีใช้งาน

```js
// เรียงตัวเลขตามค่าของมัน
const numbers = [3, 1, 4, 1, 5, 9, 2, 6];
const sorted = sortBy(numbers, x => x);
console.log(sorted); // [1, 1, 2, 3, 4, 5, 6, 9]

// เรียงอ็อบเจ็กต์ตาม property
const users = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 },
  { name: 'Charlie', age: 35 }
];
const sortedByAge = sortBy(users, user => user.age);
console.log(sortedByAge); // [{name: 'Bob', age: 25}, {name: 'Alice', age: 30}, {name: 'Charlie', age: 35}]
```

### หมายเหตุ

- ฟังก์ชันนี้ไม่แก้ไขอาเรย์เดิม (immutable)
- การเรียงลำดับเป็นแบบ ascending (จากน้อยไปมาก)
- หากต้องการเรียงแบบ descending สามารถใช้ `fn(b) - fn(a)` แทน
