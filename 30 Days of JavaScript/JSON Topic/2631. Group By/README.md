## 2631. Group By

**โจทย์**: เพิ่มเมธอด `groupBy` ให้กับ `Array.prototype` ที่รับฟังก์ชัน `fn` แล้วจัดกลุ่มสมาชิกของอาเรย์โดยใช้ค่าที่ได้จาก `fn(item)` เป็นคีย์ ผลลัพธ์เป็นอ็อบเจ็กต์ที่คีย์ชี้ไปยังอาเรย์ของสมาชิกที่อยู่ในกลุ่มนั้น ๆ

### ลายเซ็นฟังก์ชัน

```js
Array.prototype.groupBy = function (fn) => Object
```

### ตัวอย่าง

```js
[1, 2, 3].groupBy(String)
// ผลลัพธ์: { "1": [1], "2": [2], "3": [3] }

[{id: 1}, {id: 2}, {id: 1}].groupBy(x => x.id)
// ผลลัพธ์: { "1": [{id:1}, {id:1}], "2": [{id:2}] }

[6.1, 4.2, 6.3].groupBy(Math.floor)
// ผลลัพธ์: { "4": [4.2], "6": [6.1, 6.3] }
```

หมายเหตุ: คีย์ของอ็อบเจ็กต์ผลลัพธ์ถูกแปลงเป็นสตริงอัตโนมัติ (คุณสมบัติของคีย์อ็อบเจ็กต์ใน JavaScript)

### แนวคิดวิธีแก้ (ที่ใช้ในไฟล์ `solution.js`)

- ใช้ `Array.prototype.reduce` เพื่อสะสมผลเป็นอ็อบเจ็กต์ `acc`
- สำหรับแต่ละ `item` คำนวณคีย์ด้วย `fn(item)`
- หากยังไม่มีกลุ่มนั้นใน `acc` ให้สร้างเป็นอาเรย์ว่าง แล้ว `push` ค่า `item` ลงไป
- คืนค่า `acc` เมื่อวนลูปครบทุกสมาชิก

### โค้ด (ดูใน `solution.js`)

```js
Array.prototype.groupBy = function(fn) {
  return this.reduce((acc, item) => {
    const key = fn(item)
    if (!acc[key]) {
      acc[key] = []
    }
    acc[key].push(item)
    return acc
  }, {})
}
```

### ความซับซ้อน

- เวลา: O(n) — เดินอาเรย์หนึ่งครั้ง
- หน่วยความจำ: O(k + n) — มีคีย์ k กลุ่มและเก็บสมาชิกทั้งหมด n ตัวในอ็อบเจ็กต์ผลลัพธ์

### กรณีขอบ (Edge Cases)

- อาเรย์ว่าง `[]` ควรคืน `{}`
- ฟังก์ชัน `fn` คืนค่า `undefined` หรือ `null` ได้ คีย์จะถูกแปลงเป็นสตริง (`"undefined"`, `"null"`)
- หาก `fn` สร้างคีย์ที่ชนกัน ค่าจะถูกจัดกลุ่มรวมในคีย์เดียวกันตามที่คาดหวัง

### วิธีใช้งาน

เพียงนำเข้า/ประกาศโค้ดขยาย `Array.prototype.groupBy` ไว้ครั้งเดียว จากนั้นสามารถเรียกใช้ได้กับทุกอาเรย์ในสโคปนั้น


